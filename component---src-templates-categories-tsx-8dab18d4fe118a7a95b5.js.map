{"version":3,"sources":["webpack:///./src/components/json/CategoryJsonLd.tsx","webpack:///./src/templates/categories.tsx"],"names":["CategoryJsonLD","categorySlug","categoryName","query","jsonLdCategoryQuery","render","data","siteUrl","site","siteMetadata","jsonBreadCrumbs","type","JSON","stringify","Heading","styled","h1","CategoryTemplate","this","props","pageContext","posts","allMarkdownRemark","edges","location","category","categories","categoryObject","find","cat","slug","name","Layout","title","SEO","CategoryJsonLd","MainWrapper","Category","Posts","bio","Bio","tableOfContents","React","Component","Fragment","CategoryMenu","map","node","PostCard","key","fields","pageQuery"],"mappings":"iYAmDeA,EAzCQ,SAAC,GAA0C,IAAxCC,EAAwC,EAAxCA,aAAcC,EAA0B,EAA1BA,aACtC,OACE,kBAAC,cAAD,CACEC,MAAOC,EACPC,OAAQ,SAACC,GAAsB,IACrBC,EAAYD,EAAKE,KAAKC,aAAtBF,QAEFG,EAAkB,CACtB,WAAY,oBACZ,QAAS,iBACT,gBAAmB,CACjB,CACE,QAAS,WACT,SAAY,EACZ,KAAQ,CACN,MAAOH,EACP,KAAQ,SAGZ,CACE,QAAS,WACT,SAAY,EACZ,KAAQ,CACN,MAAUA,EAAV,IAAqBN,EACrB,KAAQC,MAKhB,OACE,kBAAC,IAAD,KACE,4BAAQS,KAAK,uBACVC,KAAKC,UAAUH,MA9B1B,UAyCEN,EAAsB,Y,gDCzC5B,IAAMU,EAAUC,IAAOC,GAAV,0EAAGD,CAAH,6JAePE,E,gLACJZ,OAAA,WAAS,MACuBa,KAAKC,MAA3Bb,EADD,EACCA,KAAMc,EADP,EACOA,YACRC,EAAQf,EAAKgB,kBAAkBC,MAC7BC,EAAaN,KAAKC,MAAlBK,SAEFvB,EAAemB,EAAYK,SAC3BC,EAAapB,EAAKE,KAAKC,aAAaiB,WACpCC,EAAiBD,EAAWE,MAAK,SAAAC,GACrC,OAAOA,EAAIC,OAAS7B,KAIhBC,EAAeyB,EAAiBA,EAAeI,KAAO9B,EAE5D,OACE,kBAAC+B,EAAA,EAAD,CAAQR,SAAUN,KAAKC,MAAMK,SAAUS,MAAO/B,GAC5C,kBAACgC,EAAA,EAAD,CAAKD,MAAO/B,IACZ,kBAACiC,EAAD,CAAgBlC,aAAcA,EAAcC,aAAcA,IAC1D,kBAACkC,EAAA,EAAD,CAAaX,SAAUY,EAAS,CAAEb,WAAUE,aAAYxB,iBAAiBmB,MAAOiB,EAAM,CAAEjB,UAAUkB,IAAK,kBAACC,EAAA,EAAD,MAASC,gBAAiB,S,GAnB1GC,IAAMC,WA2B/BN,GAFSpB,YAEE,SAAC,GAAgD,IAA9CO,EAA8C,EAA9CA,SAAUE,EAAoC,EAApCA,WAAYxB,EAAwB,EAAxBA,aACxC,OACE,kBAAC,IAAM0C,SAAP,KACE,kBAACC,EAAA,EAAD,CAAcrB,SAAUA,EAAUE,WAAYA,IAC9C,kBAACZ,EAAD,KAAUZ,MAKVoC,EAAQ,SAAC,GACb,OADgC,EAAjBjB,MACFyB,KAAI,YAAmB,IAAhBC,EAAgB,EAAhBA,KAClB,OAAO,kBAACC,EAAA,EAAD,CAAUC,IAAKF,EAAKG,OAAOpB,KAAMiB,KAAMA,QAIrCI,EAAY","file":"component---src-templates-categories-tsx-8dab18d4fe118a7a95b5.js","sourcesContent":["import { graphql, StaticQuery } from 'gatsby';\nimport React from 'react';\nimport Helmet from 'react-helmet';\nimport { QueryResult } from '../../models';\n\ninterface Props {\n  categorySlug: string;\n  categoryName: string;\n}\n\nconst CategoryJsonLD = ({ categorySlug, categoryName }: Props) => {\n  return (\n    <StaticQuery\n      query={jsonLdCategoryQuery}\n      render={(data: QueryResult) => {\n        const { siteUrl } = data.site.siteMetadata;\n        // bread crumbs\n        const jsonBreadCrumbs = {\n          '@context': 'http://schema.org',\n          '@type': 'BreadcrumbList',\n          'itemListElement': [\n            {\n              '@type': 'ListItem',\n              'position': 1,\n              'item': {\n                '@id': siteUrl,\n                'name': 'HOME',\n              },\n            },\n            {\n              '@type': 'ListItem',\n              'position': 2,\n              'item': {\n                '@id': `${siteUrl}/${categorySlug}`,\n                'name': categoryName,\n              },\n            },\n          ],\n        };\n        return (\n          <Helmet>\n            <script type='application/ld+json'>\n              {JSON.stringify(jsonBreadCrumbs)}\n            </script>\n          </Helmet>\n        );\n      }}\n    />\n  );\n};\n\nexport default CategoryJsonLD;\n\nconst jsonLdCategoryQuery = graphql`\n  query jsonLdCategoryQuery {\n    site {\n      siteMetadata {\n        siteUrl\n      }\n    }\n  }\n`;\n","import { graphql } from 'gatsby';\nimport React from 'react';\nimport styled from 'styled-components';\nimport Bio from '../components/Bio';\nimport CategoryMenu from '../components/CategoryMenu';\nimport CategoryJsonLd from '../components/json/CategoryJsonLd';\nimport Layout from '../components/Layout';\nimport MainWrapper from '../components/MainWrapper';\nimport PostCard from '../components/PostCard';\nimport SEO from '../components/SEO';\nimport { CategoryPageContext, QueryResult } from '../models';\n\nconst Heading = styled.h1`\n  margin: 0.5em 0 0.8em;\n  font-size: 32px;\n  transition: all 0.3s ease-in-out 0s; /* 테마 변환 시 애니메이션 */\n  color: var(--categoryHeader);\n  font-weight: 700;\n  line-height: 44px;\n  letter-spacing: 1px;\n`;\n\ninterface Props {\n  data: QueryResult;\n  pageContext: CategoryPageContext;\n  location: any;\n}\nclass CategoryTemplate extends React.Component<Props> {\n  render() {\n    const { data, pageContext } = this.props;\n    const posts = data.allMarkdownRemark.edges;\n    const { location } = this.props;\n    // get Category name from category slug\n    const categorySlug = pageContext.category;\n    const categories = data.site.siteMetadata.categories;\n    const categoryObject = categories.find(cat => {\n      return cat.slug === categorySlug;\n    });\n\n    // use slug when name doesn't exist\n    const categoryName = categoryObject ? categoryObject.name : categorySlug;\n\n    return (\n      <Layout location={this.props.location} title={categoryName}>\n        <SEO title={categoryName} />\n        <CategoryJsonLd categorySlug={categorySlug} categoryName={categoryName} />\n        <MainWrapper category={Category({ location, categories, categoryName })} posts={Posts({ posts })} bio={<Bio />} tableOfContents={null} />\n      </Layout>\n    );\n  }\n}\n\nexport default CategoryTemplate;\n\nconst Category = ({ location, categories, categoryName }: any) => {\n  return (\n    <React.Fragment>\n      <CategoryMenu location={location} categories={categories} />\n      <Heading>{categoryName}</Heading>\n    </React.Fragment>\n  );\n};\n\nconst Posts = ({ posts }: any) => {\n  return posts.map(({ node }: any) => {\n    return <PostCard key={node.fields.slug} node={node} />;\n  });\n};\n\nexport const pageQuery = graphql`\n  query BlogPostByCategory($category: String) {\n    site {\n      siteMetadata {\n        categories {\n          name\n          slug\n          color\n          icon\n          link\n        }\n      }\n    }\n    allMarkdownRemark(limit: 1000, sort: { fields: [frontmatter___date], order: DESC }, filter: { frontmatter: { category: { eq: $category } } }) {\n      edges {\n        node {\n          fields {\n            slug\n          }\n          frontmatter {\n            date(formatString: \"YYYY.MM.DD\")\n            title\n            emoji\n            category\n          }\n        }\n      }\n    }\n  }\n`;\n"],"sourceRoot":""}